package datastructures.worklists;

import cse332.exceptions.NotYetImplementedException;
import cse332.interfaces.worklists.PriorityWorkList;

import java.util.Arrays;
import java.util.NoSuchElementException;

/**
 * See cse332/interfaces/worklists/PriorityWorkList.java
 * for method specifications.
 */
    public class MinFourHeapComparable<E extends Comparable<E>> extends PriorityWorkList<E> {
        /* Do not change the name of this field; the tests rely on it to work correctly. */
        private E[] data;
        private int size;

        public MinFourHeapComparable() {
            this.data = (E[]) new Comparable[10];
            this.size = 0;
        }

        @Override
        public boolean hasWork() {
            return this.size() > 0;
        }

        private int percolateUp(int hole, E val) {
            while (hole > 0) {
                int parent = (hole - 1) / 4;
                if (0 <= val.compareTo(data[parent])) {
                    break;
                }
                data[hole] = data[parent];
                hole = parent;
            }
            return hole;
        }

        @Override
        public void add(E work) {
            if (this.size == data.length + 1) {
                data = Arrays.copyOf(data, data.length * 2);
            }
            size++;
            int i = percolateUp(this.size, (E) work);
            data[i] = (E) work;
        }

        @Override
        public E peek() {
            if (!hasWork()) {
                throw new NoSuchElementException();
            }
            return data[0];
        }

        private int percolateDown(int hole, E   val) {
            while(2 * hole <= this.size()) {

            }
            return hole;
        }

        @Override
        public E next() {
            if (!hasWork()) {
                throw new NoSuchElementException();
            }
            if (this.size == 1) {
                this.size--;
                return data[0];
            }
            E first = this.data[0];
            E last = this.data[this.size() - 1];
            size--;
            int i = percolateDown(0, last);
            this.data[i] = last;
            return first;
        }

        @Override
        public int size() {
            return this.size;
        }

        @Override
        public void clear() {
            this.data = (E[]) new Comparable[10];
            this.size = 0;
        }
    }
